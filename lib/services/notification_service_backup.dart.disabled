import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:flutter_local_notifications/flutter_local_notifications.dart';
import 'package:timezone/timezone.dart' as tz;
import 'package:timezone/data/latest.dart' as tz;

class NotificationService {
  static final FlutterLocalNotificationsPlugin _flutterLocalNotificationsPlugin = FlutterLocalNotificationsPlugin();

  static Future<void> initialize() async {
    try {
      if (kDebugMode) {
        print('=== INICIANDO NOTIFICATION SERVICE ===');
      }

      // Inicializa timezone
      try {
        tz.initializeTimeZones();
        if (kDebugMode) {
          print('‚úÖ Timezone inicializado com sucesso');
        }
      } catch (e) {
        if (kDebugMode) {
          print('‚ùå Erro ao inicializar timezone: $e');
        }
      }

      // Configura√ß√£o para Android
      const AndroidInitializationSettings initializationSettingsAndroid =
          AndroidInitializationSettings('@mipmap/ic_launcher');

      // Configura√ß√£o para iOS
      const DarwinInitializationSettings initializationSettingsIOS =
          DarwinInitializationSettings(
            requestAlertPermission: true,
            requestBadgePermission: true,
            requestSoundPermission: true,
          );

      const InitializationSettings initializationSettings =
          InitializationSettings(
            android: initializationSettingsAndroid,
            iOS: initializationSettingsIOS,
          );

      final initialized = await _flutterLocalNotificationsPlugin.initialize(
        initializationSettings,
        onDidReceiveNotificationResponse: (NotificationResponse response) {
          if (kDebugMode) {
            print('Notifica√ß√£o clicada: ${response.payload}');
          }
        },
      );

      if (kDebugMode) {
        print('NotificationService inicializado: $initialized');
      }

      // Solicita permiss√µes no Android 13+
      await _requestPermissions();

      // Cria os canais de notifica√ß√£o no Android
      await _createNotificationChannels();

      // Limpa notifica√ß√µes de teste residuais
      await cleanTestNotifications();

      if (kDebugMode) {
        print('‚úÖ NotificationService inicializado completamente');
      }
    } catch (e) {
      if (kDebugMode) {
        print('‚ùå Erro ao inicializar NotificationService: $e');
      }
      rethrow;
    }
  }

  static Future<void> _createNotificationChannels() async {
    try {
      final androidImplementation = _flutterLocalNotificationsPlugin
          .resolvePlatformSpecificImplementation<
            AndroidFlutterLocalNotificationsPlugin
          >();

      if (androidImplementation != null) {
        // Canal para notifica√ß√µes instant√¢neas
        const instantChannel = AndroidNotificationChannel(
          'instant_notification_channel',
          'Notifica√ß√µes Instant√¢neas',
          description: 'Notifica√ß√µes imediatas do Desafio52',
          importance: Importance.high,
          playSound: true,
          enableVibration: true,
        );

        // Canal para lembretes semanais
        const weeklyChannel = AndroidNotificationChannel(
          'weekly_reminder_channel',
          'Lembretes Semanais',
          description: 'Notifica√ß√µes semanais para revisar sua meta financeira',
          importance: Importance.high,
          playSound: true,
          enableVibration: true,
        );

        // Canal para lembretes de poupan√ßa - CR√çTICO
        const savingChannel = AndroidNotificationChannel(
          'saving_reminder_channel',
          'Lembretes de Poupan√ßa',
          description:
              'Notifica√ß√µes CR√çTICAS para lembrar de poupar dinheiro semanalmente',
          importance: Importance.max, // M√°xima import√¢ncia
          playSound: true,
          enableVibration: true,
          enableLights: true,
        );

        await androidImplementation.createNotificationChannel(instantChannel);
        await androidImplementation.createNotificationChannel(weeklyChannel);
        await androidImplementation.createNotificationChannel(savingChannel);

        if (kDebugMode) {
          print('‚úÖ Canais de notifica√ß√£o criados com sucesso');
        }
      }
    } catch (e) {
      if (kDebugMode) {
        print('‚ùå Erro ao criar canais de notifica√ß√£o: $e');
      }
    }
  }

  static Future<void> _requestPermissions() async {
    try {
      final androidImplementation = _flutterLocalNotificationsPlugin
          .resolvePlatformSpecificImplementation<
            AndroidFlutterLocalNotificationsPlugin
          >();

      if (androidImplementation != null) {
        final granted = await androidImplementation
            .requestNotificationsPermission();
        if (kDebugMode) {
          print('Permiss√£o de notifica√ß√£o concedida: $granted');
        }

        // Tamb√©m solicita permiss√£o para alarmes exatos (Android 12+)
        try {
          final exactAlarmGranted = await androidImplementation
              .requestExactAlarmsPermission();
          if (kDebugMode) {
            print('Permiss√£o de alarme exato concedida: $exactAlarmGranted');
          }
        } catch (e) {
          if (kDebugMode) {
            print('Erro ao solicitar permiss√£o de alarme exato: $e');
          }
        }
      }
    } catch (e) {
      if (kDebugMode) {
        print('Erro ao solicitar permiss√µes: $e');
      }
    }
  }

  static tz.TZDateTime _convertToTZDateTime(DateTime dateTime) {
    try {
      // Converte para timezone de S√£o Paulo
      final location = tz.getLocation('America/Sao_Paulo');
      return tz.TZDateTime.from(dateTime, location);
    } catch (e) {
      if (kDebugMode) {
        print('‚ùå Erro ao converter timezone, usando local: $e');
      }
      // Fallback para timezone local
      return tz.TZDateTime.from(dateTime, tz.local);
    }
  }

  // M√©todos para lembrete de poupan√ßa
  static Future<void> scheduleSavingReminderWithSchedule({
    required int dayOfWeek, // 1 = Segunda, 2 = Ter√ßa, ..., 7 = Domingo
    required int hour,
    required int minute,
  }) async {
    try {
      if (kDebugMode) {
        print('=== INICIANDO AGENDAMENTO DE POUPAN√áA ===');
        print('Dia da semana: $dayOfWeek');
        print('Hora: $hour');
        print('Minuto: $minute');
        print('Data/hora atual: ${DateTime.now()}');
      }

      // Cancela notifica√ß√µes anteriores
      await cancelSavingReminder();
      if (kDebugMode) {
        print('Notifica√ß√µes anteriores canceladas');
      }

      // Calcula a pr√≥xima data para a notifica√ß√£o
      final now = DateTime.now();
      DateTime scheduledDate = DateTime(
        now.year,
        now.month,
        now.day,
        hour,
        minute,
      );

      if (kDebugMode) {
        print('Data base calculada: $scheduledDate');
      }

      // Ajusta para o dia da semana correto
      final currentWeekday = now.weekday; // 1 = Segunda, 7 = Domingo
      final daysUntilTarget = (dayOfWeek - currentWeekday) % 7;

      if (kDebugMode) {
        print('Dia da semana atual: $currentWeekday');
        print('Dias at√© o target: $daysUntilTarget');
      }

      if (daysUntilTarget == 0 && now.isAfter(scheduledDate)) {
        // Se √© hoje mas j√° passou o hor√°rio, agenda para pr√≥xima semana
        scheduledDate = scheduledDate.add(const Duration(days: 7));
        if (kDebugMode) {
          print('Hoje mas j√° passou o hor√°rio, agendando para pr√≥xima semana');
        }
      } else if (daysUntilTarget > 0) {
        // Agenda para o pr√≥ximo dia da semana
        scheduledDate = scheduledDate.add(Duration(days: daysUntilTarget));
        if (kDebugMode) {
          print('Agendando para o pr√≥ximo dia da semana');
        }
      }

      if (kDebugMode) {
        print('Data final agendada: $scheduledDate');
        print('Diferen√ßa em rela√ß√£o a agora: ${scheduledDate.difference(now)}');
      }

      // Configura√ß√µes mais agressivas para notifica√ß√µes de poupan√ßa
      const AndroidNotificationDetails
      androidPlatformChannelSpecifics = AndroidNotificationDetails(
        'saving_reminder_channel',
        'Lembretes de Poupan√ßa',
        channelDescription:
            'Notifica√ß√µes CR√çTICAS para lembrar de poupar dinheiro semanalmente',
        importance: Importance.max, // M√°xima import√¢ncia
        priority: Priority.max, // M√°xima prioridade
        icon: '@mipmap/ic_launcher',
        enableVibration: true,
        playSound: true,
        autoCancel: false, // N√£o remove automaticamente
        category: AndroidNotificationCategory.reminder,
        visibility: NotificationVisibility.public,
        ticker: 'üí∞ Hora de Poupar!',
      );

      const DarwinNotificationDetails iOSPlatformChannelSpecifics =
          DarwinNotificationDetails(
            presentAlert: true,
            presentBadge: true,
            presentSound: true,
          );

      const NotificationDetails platformChannelSpecifics = NotificationDetails(
        android: androidPlatformChannelSpecifics,
        iOS: iOSPlatformChannelSpecifics,
      );

      // Usa modo alarmClock primeiro (mais confi√°vel para poupan√ßa)
      bool scheduled = false;

      if (kDebugMode) {
        print('Tentando agendar com modo alarmClock...');
      }

      try {
        await _flutterLocalNotificationsPlugin.zonedSchedule(
          1002, // ID diferente do lembrete de meta
          'üí∞ Hora de Poupar!',
          'N√£o esque√ßa de separar o dinheiro desta semana para seu desafio!',
          _convertToTZDateTime(scheduledDate),
          platformChannelSpecifics,
          androidScheduleMode:
              AndroidScheduleMode.alarmClock, // Modo alarme - mais confi√°vel
          uiLocalNotificationDateInterpretation:
              UILocalNotificationDateInterpretation.absoluteTime,
          matchDateTimeComponents: DateTimeComponents.dayOfWeekAndTime,
        );
        scheduled = true;
        if (kDebugMode) {
          print(
            '‚úÖ Lembrete de poupan√ßa agendado com modo alarmClock (mais confi√°vel)',
          );
          print('ID: 1002');
        }
      } catch (e) {
        if (kDebugMode) {
          print('‚ùå Falha com alarmClock: $e');
          if (e.toString().contains('exact_alarms_not_permitted')) {
            print('üîê DIAGN√ìSTICO: Permiss√£o de alarme exato n√£o concedida');
            print(
              'üí° SUGEST√ÉO: V√° em Configura√ß√µes > Apps > Desafio52 > Permiss√µes especiais > Alarmes e lembretes',
            );
          }
          print('Tentando com exactAllowWhileIdle...');
        }

        try {
          await _flutterLocalNotificationsPlugin.zonedSchedule(
            1002,
            'üí∞ Hora de Poupar!',
            'N√£o esque√ßa de separar o dinheiro desta semana para seu desafio!',
            _convertToTZDateTime(scheduledDate),
            platformChannelSpecifics,
            androidScheduleMode: AndroidScheduleMode.exactAllowWhileIdle,
            uiLocalNotificationDateInterpretation:
                UILocalNotificationDateInterpretation.absoluteTime,
            matchDateTimeComponents: DateTimeComponents.dayOfWeekAndTime,
          );
          scheduled = true;
          if (kDebugMode) {
            print(
              '‚úÖ Lembrete de poupan√ßa agendado com modo exactAllowWhileIdle',
            );
            print('ID: 1002');
          }
        } catch (e2) {
          if (kDebugMode) {
            print('‚ùå Falha com exactAllowWhileIdle: $e2');
            print('Tentando com modo b√°sico...');
          }

          // Fallback para modo b√°sico sem alarme exato
          await _flutterLocalNotificationsPlugin.zonedSchedule(
            1002,
            'üí∞ Hora de Poupar!',
            'N√£o esque√ßa de separar o dinheiro desta semana para seu desafio!',
            _convertToTZDateTime(scheduledDate),
            platformChannelSpecifics,
            uiLocalNotificationDateInterpretation:
                UILocalNotificationDateInterpretation.absoluteTime,
            matchDateTimeComponents: DateTimeComponents.dayOfWeekAndTime,
          );
          scheduled = true;
          if (kDebugMode) {
            print(
              '‚úÖ Lembrete de poupan√ßa agendado com modo b√°sico (sem alarme exato)',
            );
            print('ID: 1002');
          }
        }
      }

      if (scheduled && kDebugMode) {
        final days = [
          'Segunda',
          'Ter√ßa',
          'Quarta',
          'Quinta',
          'Sexta',
          'S√°bado',
          'Domingo',
        ];
        final dayName = days[dayOfWeek - 1];
        final timeFormatted =
            '${hour.toString().padLeft(2, '0')}:${minute.toString().padLeft(2, '0')}';
        print('=== RESUMO DO AGENDAMENTO ===');
        print('‚úÖ Lembrete de poupan√ßa configurado!');
        print('üìÖ Dia: $dayName');
        print('‚è∞ Hor√°rio: $timeFormatted');
        print('üìÜ Pr√≥ximo lembrete: $scheduledDate');
        print('üÜî ID da notifica√ß√£o: 1002');
        print('=================================');
      }
    } catch (e) {
      if (kDebugMode) {
        print('‚ùå ERRO CR√çTICO ao agendar lembrete de poupan√ßa: $e');
        print('Tipo do erro: ${e.runtimeType}');
      }
      // Em caso de erro total, continua sem notifica√ß√µes
      rethrow;
    }
  }

  static Future<void> cancelSavingReminder() async {
    try {
      if (kDebugMode) {
        print('=== CANCELANDO LEMBRETES DE POUPAN√áA ===');
      }

      await _flutterLocalNotificationsPlugin.cancel(
        1002,
      ); // Cancela usando o ID espec√≠fico do lembrete de poupan√ßa

      // Remove tamb√©m todas as notifica√ß√µes de teste residuais
      await _flutterLocalNotificationsPlugin.cancel(
        9999,
      ); // Teste de 5 segundos
      await _flutterLocalNotificationsPlugin.cancel(8888); // Teste de 1 minuto
      await _flutterLocalNotificationsPlugin.cancel(
        7777,
      ); // Teste de 30 segundos
      await _flutterLocalNotificationsPlugin.cancel(
        6666,
      ); // Teste de 10 segundos

      if (kDebugMode) {
        print(
          '‚úÖ Lembretes de poupan√ßa cancelados (IDs: 1002, 9999, 8888, 7777, 6666)',
        );
      }
    } catch (e) {
      if (kDebugMode) {
        print('‚ùå Erro ao cancelar lembretes de poupan√ßa: $e');
      }
    }
  }

  static Future<void> showInstantNotification({
    required String title,
    required String body,
  }) async {
    try {
      const AndroidNotificationDetails androidPlatformChannelSpecifics =
          AndroidNotificationDetails(
            'instant_notification_channel',
            'Notifica√ß√µes Instant√¢neas',
            channelDescription: 'Notifica√ß√µes imediatas do Desafio52',
            importance: Importance.high,
            priority: Priority.high,
            icon: '@mipmap/ic_launcher',
            showWhen: true,
            when: null,
            enableVibration: true,
            playSound: true,
          );

      const DarwinNotificationDetails iOSPlatformChannelSpecifics =
          DarwinNotificationDetails(
            presentAlert: true,
            presentBadge: true,
            presentSound: true,
          );

      const NotificationDetails platformChannelSpecifics = NotificationDetails(
        android: androidPlatformChannelSpecifics,
        iOS: iOSPlatformChannelSpecifics,
      );

      await _flutterLocalNotificationsPlugin.show(
        0,
        title,
        body,
        platformChannelSpecifics,
      );

      if (kDebugMode) {
        print('‚úÖ Notifica√ß√£o instant√¢nea enviada: $title - $body');
      }
    } catch (e) {
      if (kDebugMode) {
        print('‚ùå Erro ao enviar notifica√ß√£o instant√¢nea: $e');
      }
    }
  }

  static Future<void> cancelAllNotifications() async {
    try {
      await _flutterLocalNotificationsPlugin.cancelAll();
      if (kDebugMode) {
        print('‚úÖ Todas as notifica√ß√µes canceladas');
      }
    } catch (e) {
      if (kDebugMode) {
        print('‚ùå Erro ao cancelar notifica√ß√µes: $e');
      }
    }
  }

  static Future<void> cleanTestNotifications() async {
    try {
      // Remove notifica√ß√µes de teste com IDs conhecidos
      await _flutterLocalNotificationsPlugin.cancel(
        9999,
      ); // Teste de 5 segundos
      await _flutterLocalNotificationsPlugin.cancel(8888); // Teste de 1 minuto
      await _flutterLocalNotificationsPlugin.cancel(
        7777,
      ); // Teste de 30 segundos
      await _flutterLocalNotificationsPlugin.cancel(
        6666,
      ); // Teste de 10 segundos
      if (kDebugMode) {
        print(
          '‚úÖ Todas as notifica√ß√µes de teste removidas (9999, 8888, 7777, 6666)',
        );
      }
    } catch (e) {
      if (kDebugMode) {
        print('‚ùå Erro ao limpar notifica√ß√µes de teste: $e');
      }
    }
  }

  static Future<void> showChallengeCompletedNotification() async {
    await showInstantNotification(
      title: 'Parab√©ns! Desafio52 Conclu√≠do! üéâ',
      body:
          'Voc√™ completou o desafio de 52 semanas! Sua disciplina financeira √© incr√≠vel!',
    );
  }

  static Future<void> showWeekCompletedNotification(
    int weekNumber,
    double amount,
  ) async {
    await showInstantNotification(
      title: 'Semana $weekNumber Conclu√≠da! ‚úÖ',
      body:
          'Voc√™ economizou R\$ ${amount.toStringAsFixed(2)} esta semana. Continue assim!',
    );
  }

  // M√©todo para testar se as notifica√ß√µes est√£o funcionando
  static Future<void> testNotifications() async {
    try {
      if (kDebugMode) {
        print('=== TESTE DE NOTIFICA√á√ïES ===');
        print('üïê Hora atual: ${DateTime.now()}');
      }

      // 1. Teste notifica√ß√£o instant√¢nea
      await _flutterLocalNotificationsPlugin.show(
        5555,
        'üß™ TESTE INSTANT√ÇNEO',
        'Se voc√™ viu isso, notifica√ß√µes b√°sicas funcionam!',
        const NotificationDetails(
          android: AndroidNotificationDetails(
            'instant_notification_channel',
            'Notifica√ß√µes Instant√¢neas',
            channelDescription: 'Teste instant√¢neo de notifica√ß√µes',
            importance: Importance.max,
            priority: Priority.max,
            icon: '@mipmap/ic_launcher',
            enableVibration: true,
            playSound: true,
            autoCancel: false,
            showWhen: true,
          ),
        ),
      );

      if (kDebugMode) {
        print('‚úÖ Notifica√ß√£o instant√¢nea enviada');
      }

      // Aguarda 2 segundos
      await Future.delayed(const Duration(seconds: 2));

      // 2. Teste notifica√ß√£o agendada para 5 segundos
      final testDate = DateTime.now().add(const Duration(seconds: 5));
      
      // Cancela notifica√ß√£o anterior se existir
      await _flutterLocalNotificationsPlugin.cancel(4444);

      // Agenda nova notifica√ß√£o
      await _flutterLocalNotificationsPlugin.zonedSchedule(
        4444,
        '‚è∞ TESTE AGENDADO',
        'Se voc√™ viu isso, agendamento funciona!',
        _convertToTZDateTime(testDate),
        const NotificationDetails(
          android: AndroidNotificationDetails(
            'saving_reminder_channel',
            'Lembretes de Poupan√ßa',
            channelDescription: 'Teste agendado de notifica√ß√µes',
            importance: Importance.max,
            priority: Priority.max,
            icon: '@mipmap/ic_launcher',
            enableVibration: true,
            playSound: true,
            autoCancel: false,
            showWhen: true,
          ),
        ),
        androidScheduleMode: AndroidScheduleMode.exactAllowWhileIdle,
        uiLocalNotificationDateInterpretation:
            UILocalNotificationDateInterpretation.absoluteTime,
      );

      if (kDebugMode) {
        print('‚úÖ Notifica√ß√£o agendada para 5 segundos');
        print('‚è∞ Aguarde para confirmar se o agendamento funciona...');
      }
    } catch (e) {
      if (kDebugMode) {
        print('‚ùå Erro no teste de notifica√ß√µes: $e');
      }
      rethrow;
    }
  }

  // M√©todo para testar notifica√ß√£o de poupan√ßa
  static Future<void> testSavingNotification() async {
      if (kDebugMode) {
        print('=== TESTE DE NOTIFICA√á√ÉO DE POUPAN√áA ===');
      }

      // Testa notifica√ß√£o instant√¢nea primeiro
      await showInstantNotification(
        title: 'üí∞ TESTE - Hora de Poupar!',
        body: 'Esta √© uma notifica√ß√£o de teste para lembretes de poupan√ßa.',
      );

      if (kDebugMode) {
        print('‚úÖ Notifica√ß√£o instant√¢nea de teste enviada');
      }

      // Agenda uma notifica√ß√£o de teste para 5 segundos no futuro
      final testDate = DateTime.now().add(const Duration(seconds: 5));

      const AndroidNotificationDetails
      androidPlatformChannelSpecifics = AndroidNotificationDetails(
        'saving_reminder_channel',
        'Lembretes de Poupan√ßa',
        channelDescription:
            'Notifica√ß√µes CR√çTICAS para lembrar de poupar dinheiro semanalmente',
        importance: Importance.max,
        priority: Priority.max,
        icon: '@mipmap/ic_launcher',
        enableVibration: true,
        playSound: true,
        autoCancel: false,
      );

      const NotificationDetails platformChannelSpecifics = NotificationDetails(
        android: androidPlatformChannelSpecifics,
      );

      // Tenta agendar uma notifica√ß√£o de teste com fallback
      bool testScheduled = false;
      String testMethod = '';

      // Primeiro tenta com alarmClock
      try {
        await _flutterLocalNotificationsPlugin.zonedSchedule(
          9999, // ID especial para teste
          'üí∞ TESTE AGENDADO - Poupan√ßa (AlarmClock)!',
          'Se voc√™ viu isso, o modo alarmClock est√° funcionando perfeitamente!',
          _convertToTZDateTime(testDate),
          platformChannelSpecifics,
          androidScheduleMode: AndroidScheduleMode.alarmClock,
          uiLocalNotificationDateInterpretation:
              UILocalNotificationDateInterpretation.absoluteTime,
        );
        testScheduled = true;
        testMethod = 'alarmClock';
        if (kDebugMode) {
          print('‚úÖ Teste agendado com sucesso usando alarmClock');
        }
      } catch (e) {
        if (kDebugMode) {
          print('‚ùå Falha no teste com alarmClock: $e');
          print('Tentando teste com modo b√°sico...');
        }

        // Fallback para modo b√°sico
        try {
          await _flutterLocalNotificationsPlugin.zonedSchedule(
            9999,
            'üí∞ TESTE AGENDADO - Poupan√ßa (B√°sico)!',
            'Se voc√™ viu isso, o sistema b√°sico est√° funcionando (precis√£o limitada)!',
            _convertToTZDateTime(testDate),
            platformChannelSpecifics,
            uiLocalNotificationDateInterpretation:
                UILocalNotificationDateInterpretation.absoluteTime,
          );
          testScheduled = true;
          testMethod = 'b√°sico';
          if (kDebugMode) {
            print('‚úÖ Teste agendado com sucesso usando modo b√°sico');
          }
        } catch (e2) {
          if (kDebugMode) {
            print('‚ùå Falha total no teste: $e2');
          }
          rethrow;
        }
      }

      if (kDebugMode && testScheduled) {
        print('=== TESTE CONCLU√çDO ===');
        print('üìÖ Data do teste: $testDate');
        print('üîß M√©todo usado: $testMethod');
        print('üÜî ID da notifica√ß√£o: 9999');
        print('‚è±Ô∏è Aguarde 5 segundos para ver a notifica√ß√£o...');
      }
    } catch (e) {
      if (kDebugMode) {
        print('‚ùå Erro no teste de notifica√ß√£o: $e');
      }
      rethrow;
    }
  }

  // NOVO M√âTODO: Teste para 1 minuto no futuro - VERS√ÉO ROBUSTA
  static Future<void> testSavingIn1Minute() async {
    try {
      if (kDebugMode) {
        print('=== TESTE DE POUPAN√áA EM 1 MINUTO ===');
        print('üïê Hora atual: ${DateTime.now()}');
      }

      // Cancela qualquer notifica√ß√£o de teste anterior
      await _flutterLocalNotificationsPlugin.cancel(8888);
      if (kDebugMode) {
        print('üóëÔ∏è Notifica√ß√£o de teste anterior cancelada (ID: 8888)');
      }

      // Agenda uma notifica√ß√£o de teste para 1 minuto no futuro
      final testDate = DateTime.now().add(const Duration(minutes: 1));
      if (kDebugMode) {
        print('üéØ Data alvo: $testDate');
      }

      const AndroidNotificationDetails
      androidPlatformChannelSpecifics = AndroidNotificationDetails(
        'saving_reminder_channel',
        'Lembretes de Poupan√ßa',
        channelDescription:
            'Notifica√ß√µes CR√çTICAS para lembrar de poupar dinheiro semanalmente',
        importance: Importance.max,
        priority: Priority.max,
        icon: '@mipmap/ic_launcher',
        enableVibration: true,
        playSound: true,
        autoCancel: false,
        category: AndroidNotificationCategory.alarm,
        fullScreenIntent: true,
        visibility: NotificationVisibility.public,
      );

      const NotificationDetails platformChannelSpecifics = NotificationDetails(
        android: androidPlatformChannelSpecifics,
      );

      // Verifica permiss√µes antes de agendar
      final androidImplementation = _flutterLocalNotificationsPlugin
          .resolvePlatformSpecificImplementation<
            AndroidFlutterLocalNotificationsPlugin
          >();

      bool canScheduleExact = false;
      if (androidImplementation != null) {
        try {
          canScheduleExact =
              await androidImplementation.canScheduleExactNotifications() ??
              false;
          if (kDebugMode) {
            print('üîê Pode agendar alarmes exatos: $canScheduleExact');
          }
        } catch (e) {
          if (kDebugMode) {
            print('‚ùì N√£o foi poss√≠vel verificar permiss√µes: $e');
          }
        }
      }

      // Tenta com m√∫ltiplos m√©todos
      bool scheduled = false;
      String method = '';

      // M√©todo 1: alarmClock (mais confi√°vel)
      if (!scheduled) {
        try {
          await _flutterLocalNotificationsPlugin.zonedSchedule(
            8888,
            'üö® TESTE 1 MINUTO - AlarmClock',
            'Se voc√™ viu isso, o modo alarmClock est√° funcionando! ${DateTime.now()}',
            _convertToTZDateTime(testDate),
            platformChannelSpecifics,
            androidScheduleMode: AndroidScheduleMode.alarmClock,
            uiLocalNotificationDateInterpretation:
                UILocalNotificationDateInterpretation.absoluteTime,
          );
          scheduled = true;
          method = 'alarmClock';
          if (kDebugMode) {
            print('‚úÖ Agendado com ALARM CLOCK');
          }
        } catch (e) {
          if (kDebugMode) {
            print('‚ùå Falha com alarmClock: $e');
          }
        }
      }

      // M√©todo 2: exactAllowWhileIdle
      if (!scheduled) {
        try {
          await _flutterLocalNotificationsPlugin.zonedSchedule(
            8888,
            'üö® TESTE 1 MINUTO - ExactAllowWhileIdle',
            'Se voc√™ viu isso, o modo exactAllowWhileIdle est√° funcionando! ${DateTime.now()}',
            _convertToTZDateTime(testDate),
            platformChannelSpecifics,
            androidScheduleMode: AndroidScheduleMode.exactAllowWhileIdle,
            uiLocalNotificationDateInterpretation:
                UILocalNotificationDateInterpretation.absoluteTime,
          );
          scheduled = true;
          method = 'exactAllowWhileIdle';
          if (kDebugMode) {
            print('‚úÖ Agendado com EXACT ALLOW WHILE IDLE');
          }
        } catch (e) {
          if (kDebugMode) {
            print('‚ùå Falha com exactAllowWhileIdle: $e');
          }
        }
      }

      // M√©todo 3: b√°sico
      if (!scheduled) {
        try {
          await _flutterLocalNotificationsPlugin.zonedSchedule(
            8888,
            'üö® TESTE 1 MINUTO - B√°sico',
            'Se voc√™ viu isso, o modo b√°sico est√° funcionando! ${DateTime.now()}',
            _convertToTZDateTime(testDate),
            platformChannelSpecifics,
            uiLocalNotificationDateInterpretation:
                UILocalNotificationDateInterpretation.absoluteTime,
          );
          scheduled = true;
          method = 'b√°sico';
          if (kDebugMode) {
            print('‚úÖ Agendado com MODO B√ÅSICO');
          }
        } catch (e) {
          if (kDebugMode) {
            print('‚ùå Falha total com modo b√°sico: $e');
          }
          rethrow;
        }
      }

      if (scheduled && kDebugMode) {
        print('=== TESTE AGENDADO COM SUCESSO ===');
        print('üÜî ID: 8888');
        print('‚è∞ Aguarde 1 minuto...');
        print('üîß M√©todo: $method');
        print('üïê Hora atual: ${DateTime.now()}');
        print('üéØ Hora do teste: $testDate');
        print('üîê Permiss√£o exata: $canScheduleExact');
        print('=====================================');
      }

      // Verifica se foi realmente agendado
      final pendingNotifications = await _flutterLocalNotificationsPlugin
          .pendingNotificationRequests();
      final testNotification = pendingNotifications
          .where((n) => n.id == 8888)
          .firstOrNull;

      if (testNotification != null && kDebugMode) {
        print('‚úÖ CONFIRMADO: Notifica√ß√£o 8888 est√° na fila!');
        print('   T√≠tulo: ${testNotification.title}');
      } else if (kDebugMode) {
        print('‚ö†Ô∏è ATEN√á√ÉO: Notifica√ß√£o 8888 n√£o encontrada na fila!');
      }
    } catch (e) {
      if (kDebugMode) {
        print('‚ùå ERRO CR√çTICO no teste de 1 minuto: $e');
        print('Tipo: ${e.runtimeType}');
      }
      rethrow;
    }
  }

  // M√âTODO ADICIONAL: Teste ultra-r√°pido (30 segundos) - VERS√ÉO SUPER ROBUSTA
  static Future<void> testSavingIn30Seconds() async {
    try {
      if (kDebugMode) {
        print('=== TESTE ULTRA-R√ÅPIDO EM 30 SEGUNDOS ===');
        print('üïê Hora atual: ${DateTime.now()}');
      }

      // Cancela qualquer notifica√ß√£o de teste anterior
      await _flutterLocalNotificationsPlugin.cancel(7777);
      if (kDebugMode) {
        print('üóëÔ∏è Notifica√ß√£o anterior ID:7777 cancelada');
      }

      // Agenda uma notifica√ß√£o de teste para 30 segundos no futuro
      final testDate = DateTime.now().add(const Duration(seconds: 30));
      if (kDebugMode) {
        print('üéØ Data alvo: $testDate');
        print(
          '‚è±Ô∏è Diferen√ßa: ${testDate.difference(DateTime.now()).inSeconds} segundos',
        );
      }

      // Verifica permiss√µes ANTES de tentar agendar
      final androidImplementation = _flutterLocalNotificationsPlugin
          .resolvePlatformSpecificImplementation<
            AndroidFlutterLocalNotificationsPlugin
          >();

      bool hasExactAlarmPermission = false;
      if (androidImplementation != null) {
        try {
          hasExactAlarmPermission =
              await androidImplementation.canScheduleExactNotifications() ??
              false;
          if (kDebugMode) {
            print('üîê Permiss√£o de alarme exato: $hasExactAlarmPermission');
          }
        } catch (e) {
          if (kDebugMode) {
            print('‚ùì Erro ao verificar permiss√µes: $e');
          }
        }
      }

      // Configura√ß√£o M√ÅXIMA de notifica√ß√£o
      const AndroidNotificationDetails androidPlatformChannelSpecifics =
          AndroidNotificationDetails(
            'saving_reminder_channel',
            'Lembretes de Poupan√ßa',
            channelDescription: 'Teste ultra-r√°pido de 30 segundos',
            importance: Importance.max,
            priority: Priority.max,
            icon: '@mipmap/ic_launcher',
            enableVibration: true,
            playSound: true,
            autoCancel: false,
            category: AndroidNotificationCategory.alarm,
            fullScreenIntent: true,
            visibility: NotificationVisibility.public,
            ongoing: false,
            showWhen: true,
            ticker: '‚ö° TESTE 30 SEGUNDOS',
          );

      const NotificationDetails platformChannelSpecifics = NotificationDetails(
        android: androidPlatformChannelSpecifics,
      );

      bool scheduled = false;
      String method = '';

      // ESTRAT√âGIA 1: Se tem permiss√£o, usa alarmClock
      if (hasExactAlarmPermission) {
        try {
          await _flutterLocalNotificationsPlugin.zonedSchedule(
            7777,
            '‚ö° TESTE 30s - ALARME EXATO!',
            'Funcionou! Alarmes exatos est√£o ativos! üéâ ${DateTime.now().millisecondsSinceEpoch}',
            _convertToTZDateTime(testDate),
            platformChannelSpecifics,
            androidScheduleMode: AndroidScheduleMode.alarmClock,
            uiLocalNotificationDateInterpretation:
                UILocalNotificationDateInterpretation.absoluteTime,
          );
          scheduled = true;
          method = 'alarmClock';
          if (kDebugMode) {
            print('‚úÖ AGENDADO com alarmClock (permiss√£o confirmada)');
          }
        } catch (e) {
          if (kDebugMode) {
            print('‚ùå Falha com alarmClock: $e');
          }
        }
      }

      // ESTRAT√âGIA 2: exactAllowWhileIdle (funciona mesmo sem permiss√£o espec√≠fica)
      if (!scheduled) {
        try {
          await _flutterLocalNotificationsPlugin.zonedSchedule(
            7777,
            '‚ö° TESTE 30s - EXACT WHILE IDLE!',
            'Funcionou! ExactAllowWhileIdle ativo! üéâ ${DateTime.now().millisecondsSinceEpoch}',
            _convertToTZDateTime(testDate),
            platformChannelSpecifics,
            androidScheduleMode: AndroidScheduleMode.exactAllowWhileIdle,
            uiLocalNotificationDateInterpretation:
                UILocalNotificationDateInterpretation.absoluteTime,
          );
          scheduled = true;
          method = 'exactAllowWhileIdle';
          if (kDebugMode) {
            print('‚úÖ AGENDADO com exactAllowWhileIdle');
          }
        } catch (e) {
          if (kDebugMode) {
            print('‚ùå Falha com exactAllowWhileIdle: $e');
          }
        }
      }

      // ESTRAT√âGIA 3: Modo b√°sico (sem precis√£o garantida)
      if (!scheduled) {
        try {
          await _flutterLocalNotificationsPlugin.zonedSchedule(
            7777,
            '‚ö° TESTE 30s - MODO B√ÅSICO!',
            'Funcionou! Modo b√°sico ativo (sem precis√£o)! üéâ ${DateTime.now().millisecondsSinceEpoch}',
            _convertToTZDateTime(testDate),
            platformChannelSpecifics,
            uiLocalNotificationDateInterpretation:
                UILocalNotificationDateInterpretation.absoluteTime,
          );
          scheduled = true;
          method = 'b√°sico';
          if (kDebugMode) {
            print('‚úÖ AGENDADO com modo b√°sico');
          }
        } catch (e) {
          if (kDebugMode) {
            print('‚ùå Falha total com modo b√°sico: $e');
          }
          rethrow;
        }
      }

      if (scheduled && kDebugMode) {
        print('=== TESTE AGENDADO COM SUCESSO ===');
        print('üÜî ID: 7777');
        print('‚è∞ Aguarde 30 segundos...');
        print('üîß M√©todo: $method');
        print('üïê Hora atual: ${DateTime.now()}');
        print('üéØ Hora do teste: $testDate');
        print('üîê Permiss√£o exata: $hasExactAlarmPermission');
        print('=====================================');
      }

      // Verifica se foi realmente agendado
      final pendingNotifications = await _flutterLocalNotificationsPlugin
          .pendingNotificationRequests();
      final testNotification = pendingNotifications
          .where((n) => n.id == 7777)
          .firstOrNull;

      if (testNotification != null && kDebugMode) {
        print('‚úÖ CONFIRMADO: Notifica√ß√£o 7777 est√° na fila!');
        print('   T√≠tulo: ${testNotification.title}');
      } else if (kDebugMode) {
        print('‚ö†Ô∏è ATEN√á√ÉO: Notifica√ß√£o 7777 n√£o encontrada na fila!');
      }
    } catch (e) {
      if (kDebugMode) {
        print('‚ùå ERRO CR√çTICO no teste de 30 segundos: $e');
        print('Tipo: ${e.runtimeType}');
      }
      rethrow;
    }
  }

  // M√âTODO ALTERNATIVO: Teste com notifica√ß√£o instant√¢nea (sem agendamento)
  static Future<void> testInstantNotificationOnly() async {
    try {
      if (kDebugMode) {
        print('=== TESTE APENAS NOTIFICA√á√ÉO INSTANT√ÇNEA ===');
        print('üïê Hora atual: ${DateTime.now()}');
      }

      // Testa canal instant√¢neo
      await showInstantNotification(
        title: 'üß™ TESTE INSTANT√ÇNEO - Canal B√°sico',
        body:
            'Se voc√™ viu isso, o canal instant√¢neo funciona! ${DateTime.now().toString().substring(11, 19)}',
      );

      if (kDebugMode) {
        print('‚úÖ Notifica√ß√£o instant√¢nea enviada no canal b√°sico');
      }

      // Aguarda 2 segundos e testa canal de poupan√ßa instantaneamente
      await Future.delayed(const Duration(seconds: 2));

      const AndroidNotificationDetails androidSpecs =
          AndroidNotificationDetails(
            'saving_reminder_channel',
            'Lembretes de Poupan√ßa',
            channelDescription: 'Teste instant√¢neo no canal de poupan√ßa',
            importance: Importance.max,
            priority: Priority.max,
            icon: '@mipmap/ic_launcher',
            enableVibration: true,
            playSound: true,
            autoCancel: false,
            showWhen: true,
            ticker: 'üí∞ TESTE POUPAN√áA',
          );

      const NotificationDetails specs = NotificationDetails(
        android: androidSpecs,
      );

      await _flutterLocalNotificationsPlugin.show(
        5555, // ID especial para este teste
        'üí∞ TESTE INSTANT√ÇNEO - Canal Poupan√ßa',
        'Se voc√™ viu isso, o canal de poupan√ßa funciona! ${DateTime.now().toString().substring(11, 19)}',
        specs,
      );

      if (kDebugMode) {
        print('‚úÖ Notifica√ß√£o instant√¢nea enviada no canal de poupan√ßa');
        print(
          'üí° Se ambas apareceram, o problema est√° no AGENDAMENTO, n√£o nos canais',
        );
        print('üí° Se nenhuma apareceu, o problema s√£o as PERMISS√ïES B√ÅSICAS');
      }
    } catch (e) {
      if (kDebugMode) {
        print('‚ùå ERRO no teste instant√¢neo: $e');
      }
      rethrow;
    }
  }

  // M√âTODO EXTREMO: Diagn√≥stico profundo do sistema Android
  static Future<void> deepAndroidDiagnostic() async {
    try {
      if (kDebugMode) {
        print('=== DIAGN√ìSTICO PROFUNDO DO ANDROID ===');
        print('üïê Hora atual: ${DateTime.now()}');
      }

      final androidImplementation = _flutterLocalNotificationsPlugin
          .resolvePlatformSpecificImplementation<
            AndroidFlutterLocalNotificationsPlugin
          >();

      if (androidImplementation != null) {
        // 1. Verifica se notifica√ß√µes b√°sicas est√£o habilitadas
        try {
          final basicEnabled = await androidImplementation
              .areNotificationsEnabled();
          if (kDebugMode) {
            print('üì¢ Notifica√ß√µes b√°sicas habilitadas: $basicEnabled');
            if (basicEnabled == false) {
              print('‚ùå PROBLEMA CR√çTICO: Notifica√ß√µes b√°sicas DESABILITADAS!');
              print(
                'üîß SOLU√á√ÉO: Configura√ß√µes > Apps > Desafio52 > Notifica√ß√µes > ATIVAR',
              );
            } else if (basicEnabled == true) {
              print('‚úÖ Notifica√ß√µes b√°sicas est√£o ATIVAS');
            } else {
              print('‚ùì Status das notifica√ß√µes b√°sicas indeterminado');
            }
          }
        } catch (e) {
          if (kDebugMode) {
            print('‚ùå Erro ao verificar notifica√ß√µes b√°sicas: $e');
          }
        }

        // 2. Verifica alarmes exatos
        try {
          final exactAlarms = await androidImplementation
              .canScheduleExactNotifications();
          if (kDebugMode) {
            print('‚è∞ Pode agendar alarmes exatos: $exactAlarms');
            if (exactAlarms == false) {
              print('‚ö†Ô∏è Alarmes exatos DESABILITADOS (normal em alguns casos)');
              print(
                'üí° Isto pode afetar precis√£o, mas n√£o deveria impedir notifica√ß√µes',
              );
            }
          }
        } catch (e) {
          if (kDebugMode) {
            print('‚ùå Erro ao verificar alarmes exatos: $e');
          }
        }

        // 3. Lista todos os canais criados
        try {
          final channels = await androidImplementation
              .getNotificationChannels();
          if (kDebugMode) {
            print(
              'üì∫ Canais de notifica√ß√£o encontrados: ${channels?.length ?? 0}',
            );
            if (channels != null) {
              for (final channel in channels) {
                print(
                  '   - ${channel.id}: ${channel.name} (Import√¢ncia: ${channel.importance})',
                );
              }
            } else {
              print('‚ùå PROBLEMA: Nenhum canal encontrado!');
            }
          }
        } catch (e) {
          if (kDebugMode) {
            print('‚ùå Erro ao listar canais: $e');
          }
        }

        // 4. Testa notifica√ß√£o com ID √∫nico e timestamp
        if (kDebugMode) {
          print('=== TESTE DE NOTIFICA√á√ÉO FOR√áADA ===');
        }

        final timestamp = DateTime.now().millisecondsSinceEpoch;
        const AndroidNotificationDetails forceSpecs =
            AndroidNotificationDetails(
              'instant_notification_channel',
              'Notifica√ß√µes Instant√¢neas',
              channelDescription: 'Teste for√ßado de notifica√ß√£o',
              importance: Importance.max,
              priority: Priority.max,
              icon: '@mipmap/ic_launcher',
              enableVibration: true,
              playSound: true,
              autoCancel: false,
              showWhen: true,
              ongoing: false,
              silent: false,
            );

        const NotificationDetails forceDetails = NotificationDetails(
          android: forceSpecs,
        );

        await _flutterLocalNotificationsPlugin.show(
          timestamp.abs() % 10000, // ID √∫nico baseado no timestamp
          'üö® DIAGN√ìSTICO FOR√áADO',
          'Teste ${timestamp} - Se voc√™ viu isso, notifica√ß√µes instant√¢neas funcionam!',
          forceDetails,
        );

        if (kDebugMode) {
          print(
            '‚úÖ Notifica√ß√£o for√ßada enviada (ID: ${timestamp.abs() % 10000})',
          );
        }
      }

      // 5. Verifica notifica√ß√µes pendentes uma √∫ltima vez
      final pending = await _flutterLocalNotificationsPlugin
          .pendingNotificationRequests();
      if (kDebugMode) {
        print('=== NOTIFICA√á√ïES PENDENTES ===');
        print('üì± Total pendentes: ${pending.length}');
        if (pending.isNotEmpty) {
          for (final notif in pending) {
            print('   - ID: ${notif.id}, T√≠tulo: ${notif.title}');
          }
        } else {
          print(
            '‚ö†Ô∏è Nenhuma notifica√ß√£o pendente (normal para testes instant√¢neos)',
          );
        }
      }

      if (kDebugMode) {
        print('=== RESUMO DO DIAGN√ìSTICO ===');
        print('1. Se a notifica√ß√£o for√ßada apareceu: O sistema funciona');
        print('2. Se n√£o apareceu: Problema de permiss√µes ou sistema');
        print('3. Verifique se DND (N√£o Perturbar) est√° desativado');
        print('4. Verifique se o app n√£o est√° em modo economia de bateria');
        print('=====================================');
      }
    } catch (e) {
      if (kDebugMode) {
        print('‚ùå ERRO CR√çTICO no diagn√≥stico profundo: $e');
      }
      rethrow;
    }
  }

  // M√âTODO EMERGENCIAL: Teste super r√°pido (10 segundos) para debugging
  static Future<void> testSavingIn10Seconds() async {
    try {
      if (kDebugMode) {
        print('=== TESTE EMERGENCIAL 10 SEGUNDOS ===');
        print('üïê Hora atual: ${DateTime.now()}');
      }

      // Cancela testes anteriores
      await _flutterLocalNotificationsPlugin.cancel(6666);

      // 10 segundos √© r√°pido demais para problemas de permiss√£o
      final testDate = DateTime.now().add(const Duration(seconds: 10));
      if (kDebugMode) {
        print('üéØ Data alvo: $testDate');
        print(
          '‚ö° Teste em ${testDate.difference(DateTime.now()).inSeconds} segundos',
        );
      }

      // Configura√ß√£o simplificada mas robusta
      const AndroidNotificationDetails
      androidSpecs = AndroidNotificationDetails(
        'instant_notification_channel', // Usa canal instant√¢neo (mais confi√°vel)
        'Notifica√ß√µes Instant√¢neas',
        channelDescription: 'Teste emergencial de 10 segundos',
        importance: Importance.max,
        priority: Priority.max,
        icon: '@mipmap/ic_launcher',
        enableVibration: true,
        playSound: true,
        autoCancel: false,
        showWhen: true,
        ticker: 'üö® TESTE 10s',
      );

      const NotificationDetails specs = NotificationDetails(
        android: androidSpecs,
      );

      // Usa estrat√©gia dupla: exactAllowWhileIdle primeiro (mais compat√≠vel)
      bool success = false;

      try {
        await _flutterLocalNotificationsPlugin.zonedSchedule(
          6666,
          'üö® TESTE 10s - EMERGENCIAL!',
          'Se apareceu, o sistema funciona! Hora: ${DateTime.now().toString().substring(11, 19)}',
          _convertToTZDateTime(testDate),
          specs,
          androidScheduleMode:
              AndroidScheduleMode.exactAllowWhileIdle, // Mais tolerante
          uiLocalNotificationDateInterpretation:
              UILocalNotificationDateInterpretation.absoluteTime,
        );
        success = true;
        if (kDebugMode) {
          print('‚úÖ TESTE 10s agendado com exactAllowWhileIdle');
        }
      } catch (e) {
        if (kDebugMode) {
          print('‚ùå Falha com exactAllowWhileIdle: $e');
        }

        // Fallback para modo b√°sico
        try {
          await _flutterLocalNotificationsPlugin.zonedSchedule(
            6666,
            'üö® TESTE 10s - B√ÅSICO!',
            'Modo b√°sico funcionou! Hora: ${DateTime.now().toString().substring(11, 19)}',
            _convertToTZDateTime(testDate),
            specs,
            uiLocalNotificationDateInterpretation:
                UILocalNotificationDateInterpretation.absoluteTime,
          );
          success = true;
          if (kDebugMode) {
            print('‚úÖ TESTE 10s agendado com modo b√°sico');
          }
        } catch (e2) {
          if (kDebugMode) {
            print('‚ùå FALHA TOTAL no teste 10s: $e2');
          }
          rethrow;
        }
      }

      if (success && kDebugMode) {
        print('=== TESTE 10s ATIVO ===');
        print('üÜî ID: 6666');
        print('‚è∞ Aguarde 10 segundos...');
        print('üí° Mantenha o app aberto por 15 segundos total');
        print('======================');
      }
    } catch (e) {
      if (kDebugMode) {
        print('‚ùå ERRO no teste emergencial: $e');
      }
      rethrow;
    }
  }

  // M√©todo para verificar notifica√ß√µes agendadas - VERS√ÉO DIAGN√ìSTICA COMPLETA
  static Future<void> checkScheduledNotifications() async {
    try {
      if (kDebugMode) {
        print('=== DIAGN√ìSTICO COMPLETO DO SISTEMA ===');
        print('üïê Hora atual: ${DateTime.now()}');
      }

      final List<PendingNotificationRequest> pendingNotifications =
          await _flutterLocalNotificationsPlugin.pendingNotificationRequests();

      if (kDebugMode) {
        print(
          'üì± Total de notifica√ß√µes pendentes: ${pendingNotifications.length}',
        );

        if (pendingNotifications.isEmpty) {
          print('‚ö†Ô∏è Nenhuma notifica√ß√£o agendada encontrada');
          print('üí° Isso pode significar que:');
          print('   - As notifica√ß√µes foram canceladas');
          print('   - Erro ao agendar');
          print('   - Permiss√µes insuficientes');
        } else {
          print('‚úÖ Notifica√ß√µes encontradas:');
          for (final notification in pendingNotifications) {
            print('---');
            print('üÜî ID: ${notification.id}');
            print('üìù T√≠tulo: ${notification.title}');
            print('üí¨ Corpo: ${notification.body}');
            if (notification.id == 1002) {
              print('üí∞ NOTIFICA√á√ÉO DE POUPAN√áA REAL');
            } else if (notification.id == 9999) {
              print('üß™ Teste de 5 segundos');
            } else if (notification.id == 8888) {
              print('‚è∞ Teste de 1 minuto');
            } else if (notification.id == 7777) {
              print('‚ö° Teste de 30 segundos');
            }
          }
        }

        // Verifica permiss√µes detalhadamente
        print('=== VERIFICA√á√ÉO DE PERMISS√ïES ===');
        final androidImplementation = _flutterLocalNotificationsPlugin
            .resolvePlatformSpecificImplementation<
              AndroidFlutterLocalNotificationsPlugin
            >();

        if (androidImplementation != null) {
          try {
            final canScheduleExact = await androidImplementation
                .canScheduleExactNotifications();
            print('üîî Pode agendar notifica√ß√µes exatas: $canScheduleExact');

            if (canScheduleExact == false) {
              print('‚ùå PROBLEMA CR√çTICO: Sem permiss√£o para alarmes exatos');
              print('üîß SOLU√á√ÉO DEFINITIVA:');
              print('   1. Abra Configura√ß√µes do Android');
              print('   2. V√° em Apps > Desafio52');
              print('   3. Permiss√µes especiais > Alarmes e lembretes');
              print(
                '   4. Ative "Permitir configura√ß√£o de alarmes e lembretes"',
              );
              print('   5. Teste novamente');
            } else if (canScheduleExact == true) {
              print('‚úÖ Permiss√£o para alarmes exatos ATIVA!');
              print('üéØ Sistema deveria funcionar perfeitamente');
            } else {
              print('‚ùì Status de permiss√£o indeterminado');
            }

            // Verifica permiss√µes b√°sicas de notifica√ß√£o
            try {
              final basicPermission = await androidImplementation
                  .areNotificationsEnabled();
              print('üì¢ Notifica√ß√µes b√°sicas ativadas: $basicPermission');
            } catch (e) {
              print('‚ùì N√£o foi poss√≠vel verificar permiss√µes b√°sicas: $e');
            }
          } catch (e) {
            print('‚ùå Erro ao verificar permiss√µes: $e');
          }
        }

        // Verifica timezone
        print('=== VERIFICA√á√ÉO DE TIMEZONE ===');
        try {
          final now = DateTime.now();
          final tzNow = _convertToTZDateTime(now);
          print('üåç Hora local: $now');
          print('üïí Hora com timezone: $tzNow');
          print('üìç Timezone: ${tzNow.location}');
        } catch (e) {
          print('‚ùå Erro de timezone: $e');
        }

        // Teste de canal de notifica√ß√£o
        print('=== TESTE DE CANAL ===');
        try {
          await showInstantNotification(
            title: 'üîç TESTE DE DIAGN√ìSTICO',
            body: 'Se voc√™ viu isso, o canal b√°sico funciona!',
          );
          print('‚úÖ Teste de canal b√°sico enviado');
        } catch (e) {
          print('‚ùå Erro no teste de canal: $e');
        }

        print('==============================');
        print('üèÅ DIAGN√ìSTICO COMPLETO FINALIZADO');
      }
    } catch (e) {
      if (kDebugMode) {
        print('‚ùå Erro ao verificar notifica√ß√µes agendadas: $e');
      }
    }
  }

  // M√âTODO DE TESTE DEFINITIVO: Testa instant√¢neo + agendado para diagnosticar o problema
  static Future<void> testUltimateNotificationTest() async {
    try {
      if (kDebugMode) {
        print('=== TESTE DEFINITIVO DE NOTIFICA√á√ïES ===');
        print('üïê Hora atual: ${DateTime.now()}');
      }

      // 1. PRIMEIRO: Teste notifica√ß√£o instant√¢nea
      if (kDebugMode) {
        print('=== FASE 1: TESTE INSTANT√ÇNEO ===');
      }

      await _flutterLocalNotificationsPlugin.show(
        5555,
        'üß™ TESTE INSTANT√ÇNEO',
        'Se voc√™ viu isso, notifica√ß√µes b√°sicas funcionam! ${DateTime.now().toString().substring(11, 19)}',
        const NotificationDetails(
          android: AndroidNotificationDetails(
            'instant_notification_channel',
            'Notifica√ß√µes Instant√¢neas',
            channelDescription: 'Teste instant√¢neo definitivo',
            importance: Importance.max,
            priority: Priority.max,
            icon: '@mipmap/ic_launcher',
            enableVibration: true,
            playSound: true,
            autoCancel: false,
            showWhen: true,
          ),
        ),
      );

      if (kDebugMode) {
        print('‚úÖ Notifica√ß√£o instant√¢nea enviada (ID: 5555)');
      }

      // Aguarda 3 segundos
      await Future.delayed(const Duration(seconds: 3));

      // 2. SEGUNDO: Teste notifica√ß√£o agendada para 5 segundos
      if (kDebugMode) {
        print('=== FASE 2: TESTE AGENDADO ===');
      }

      final testDate = DateTime.now().add(const Duration(seconds: 5));
      final tzTestDate = _convertToTZDateTime(testDate);

      if (kDebugMode) {
        print('üéØ Data alvo: $testDate');
        print('üåç Data TZ: $tzTestDate');
        print(
          '‚è±Ô∏è Diferen√ßa: ${testDate.difference(DateTime.now()).inSeconds} segundos',
        );
      }

      // Cancela notifica√ß√£o anterior
      await _flutterLocalNotificationsPlugin.cancel(4444);

      // Verifica permiss√µes
      final androidImplementation = _flutterLocalNotificationsPlugin
          .resolvePlatformSpecificImplementation<
            AndroidFlutterLocalNotificationsPlugin
          >();

      bool canScheduleExact = false;
      if (androidImplementation != null) {
        try {
          canScheduleExact =
              await androidImplementation.canScheduleExactNotifications() ??
              false;
          if (kDebugMode) {
            print('üîê Pode agendar alarmes exatos: $canScheduleExact');
          }
        } catch (e) {
          if (kDebugMode) {
            print('‚ùì Erro ao verificar permiss√µes: $e');
          }
        }
      }

      // Tenta agendar notifica√ß√£o
      await _flutterLocalNotificationsPlugin.zonedSchedule(
        4444,
        '‚è∞ TESTE AGENDADO DEFINITIVO',
        'Se voc√™ viu isso, agendamento funciona! ${DateTime.now().toString().substring(11, 19)}',
        tzTestDate,
        const NotificationDetails(
          android: AndroidNotificationDetails(
            'instant_notification_channel',
            'Notifica√ß√µes Instant√¢neas',
            channelDescription: 'Teste agendado definitivo',
            importance: Importance.max,
            priority: Priority.max,
            icon: '@mipmap/ic_launcher',
            enableVibration: true,
            playSound: true,
            autoCancel: false,
            showWhen: true,
            ticker: '‚è∞ TESTE DEFINITIVO',
          ),
        ),
        androidScheduleMode: AndroidScheduleMode.exactAllowWhileIdle,
        uiLocalNotificationDateInterpretation:
            UILocalNotificationDateInterpretation.absoluteTime,
      );

      if (kDebugMode) {
        print('‚úÖ Notifica√ß√£o agendada enviada (ID: 4444)');
      }

      // 3. TERCEIRO: Verifica se foi realmente agendado
      final pendingNotifications = await _flutterLocalNotificationsPlugin
          .pendingNotificationRequests();
      final testNotification = pendingNotifications
          .where((n) => n.id == 4444)
          .firstOrNull;

      if (kDebugMode) {
        print('=== VERIFICA√á√ÉO FINAL ===');
        print(
          'üì± Total de notifica√ß√µes pendentes: ${pendingNotifications.length}',
        );

        if (testNotification != null) {
          print('‚úÖ SUCESSO: Notifica√ß√£o 4444 est√° na fila!');
          print('   T√≠tulo: ${testNotification.title}');
          print('üí° Aguarde 5 segundos para ver se aparece...');
        } else {
          print('‚ùå PROBLEMA: Notifica√ß√£o 4444 N√ÉO est√° na fila!');
          print('üí° Isso indica falha no agendamento');

          if (!canScheduleExact) {
            print('üîç POSS√çVEL CAUSA: Sem permiss√£o para alarmes exatos');
            print(
              'üîß SOLU√á√ÉO: V√° em Configura√ß√µes > Apps > Desafio52 > Permiss√µes especiais > Alarmes e lembretes',
            );
          } else {
            print('üîç POSS√çVEL CAUSA: Limita√ß√£o do sistema ou plugin');
          }
        }

        print('üèÅ RESUMO:');
        print('   - Notifica√ß√£o instant√¢nea: Enviada');
        print(
          '   - Notifica√ß√£o agendada: ${testNotification != null ? "Na fila" : "FALHOU"}',
        );
        print('   - Permiss√£o alarmes exatos: $canScheduleExact');
      }
    } catch (e) {
      if (kDebugMode) {
        print('‚ùå ERRO no teste definitivo: $e');
        print('Tipo: ${e.runtimeType}');
      }
      rethrow;
    }
  }

  // Teste de agendamento simples para 5 segundos no futuro, sem matchDateTimeComponents
  static Future<void> testScheduleIn5Seconds() async {
    try {
      if (kDebugMode) {
        print('=== TESTE AGENDAMENTO 5 SEGUNDOS ===');
        print('üïê Hora atual: [32m[1m${DateTime.now()}[0m');
      }
      final testDate = DateTime.now().add(const Duration(seconds: 5));
      const AndroidNotificationDetails androidSpecs =
          AndroidNotificationDetails(
            'instant_notification_channel',
            'Notifica√ß√µes Instant√¢neas',
            channelDescription: 'Teste agendado para 5 segundos',
            importance: Importance.max,
            priority: Priority.max,
            icon: '@mipmap/ic_launcher',
            enableVibration: true,
            playSound: true,
            autoCancel: false,
            showWhen: true,
            ticker: '‚è∞ TESTE 5s',
          );
      const NotificationDetails specs = NotificationDetails(
        android: androidSpecs,
      );

      await _flutterLocalNotificationsPlugin.zonedSchedule(
        4444,
        '‚è∞ TESTE AGENDADO 5s',
        'Se voc√™ viu isso, o agendamento simples funciona! ${DateTime.now().toString().substring(11, 19)}',
        _convertToTZDateTime(testDate),
        specs,
        androidScheduleMode: AndroidScheduleMode.exactAllowWhileIdle,
        uiLocalNotificationDateInterpretation:
            UILocalNotificationDateInterpretation.absoluteTime,
        // N√ÉO usar matchDateTimeComponents
      );
      if (kDebugMode) {
        print('‚úÖ TESTE AGENDADO para 5 segundos no futuro');
      }
    } catch (e) {
      if (kDebugMode) {
        print('‚ùå ERRO no teste agendado 5s: $e');
      }
      rethrow;
    }
  }
}
